/// Extends a prop map by using other maps in _extend property
/// @param {Map} $map-bundle - Map to be extended
/// @return {Map} - Extended map
@function maple-extend($map-bundle) {
  $extended-map-list: ();

  @each $map-name in map-keys($map-bundle) {
    $utility-map: map-get($map-bundle, $map-name);
    $utility-map-extend: map-get($utility-map, "_extend");
    $utility-map-prefix: map-get($utility-map, "_prefix");
    $utility-map: map-merge($utility-map, (_extend: null));

    @if $utility-map-extend {
      @each $prop-map in $utility-map-extend {
        $prop-map-prefix: map-get($prop-map, "_prefix");
        $extended-map-list: map-merge(
          $extended-map-list,
          (
            #{$utility-map-prefix}-#{$prop-map-prefix}: map-collect(
              $utility-map,
              $prop-map,
              (
                _prefix: #{$utility-map-prefix}-#{$prop-map-prefix},
              ),
            ),
          ),
        );
      }
    }
  }

  @return map-merge($map-bundle, $extended-map-list);
}

/// Assigns given map's values to given property as css styles
/// @param {Map} $map - Map to be converted
/// @param {String} $prop - Property name to be mapped as css styles
/// @param {String} $prefix - Utility class prefix
/// @return {Map} - Property map
@function maple-generate($map, $prop, $prefix: $prop) {
  $prop-map: (
    _prefix: $prefix,
  );

  @if str-ends-with($prop, "-x") {
    $base-prop: str-replace($property, "-x", "");

    @each $key in map-keys($map) {
      $value: map-get($map, $key);
      $prop-map: map-merge(
        $prop-map,
        (
          "#{$key}": (
            #{$base-prop}-left: $value,
            #{$base-prop}-right: $value,
          ),
        )
      );
    }
  }
  @else if str-ends-with($prop, "-y") {
    $base-prop: str-replace($property, "-y", "");

    @each $key in map-keys($map) {
      $value: map-get($map, $key);
      $prop-map: map-merge(
        $prop-map,
        (
          "#{$key}": (
            #{$base-prop}-bottom: $value,
            #{$base-prop}-top: $value,
          ),
        ),
      );
    }
  }
  @else {
    @each $key in map-keys($map) {
      $value: map-get($map, $key);
      $prop-map: map-merge(
        $prop-map,
        (
          "#{$key}": ( #{$prop}: $value ),
        )
      );
    }
  }

  @return $prop-map;
}

/// Finds min and max keys of breakpoints that set by the consumers of maple.
/// You can expect to get xs and xl if you're just a regular person.
/// @param {Map} $bp-map - Breakpoint map to be digged
/// @return {Map} - A map having min and max keys
@function maple-bp-limits($bp-map) {
  $unknown-bp: "";

  @each $bp in map-keys($bp-map) {
    $unknown-bp: $bp;
  }

  $max-bp: $unknown-bp;

  @each $bp in map-keys($bp-map) {
    $current-bp-val: map-get($bp-map, $bp);
    $max-bp-val: map-get($bp-map, $max-bp);

    @if $current-bp-val > $max-bp-val {
      $max-bp: $bp;
    }
  }

  $min-bp: $max-bp;

  @each $bp in map-keys($bp-map) {
    $current-bp-val: map-get($bp-map, $bp);
    $min-bp-val: map-get($bp-map, $min-bp);

    @if $current-bp-val < $min-bp-val {
      $min-bp: $bp;
    }
  }

  @return (
    min: $min-bp,
    max: $max-bp,
  );
}

/// Unifies classes used in template map
/// @param {Map} $templates - Template map to be unified
/// @return {List} - Unified utility class list
@function maple-unify-used-classes($templates) {
  $utility-classes: ();

  @if empty($templates) {
    @return $utility-classes;
  }

  @each $key, $value in $templates {
    @if type-of($value == list) {
      @each $class in $value {
        @if index($utility-classes, $class) == null {
          $utility-classes: append($utility-classes, $class);
        }
      }
    }
    @else {
      @if index($utility-classes, $value) == null {
        $utility-classes: append($utility-classes, $value);
      }
    }
  }

  @return $utility-classes;
}

/// Cahce maps
/// @param {Map} $cache - Cache map
/// @param {String} $bp-key - Key to assign map on
/// @param {String} $selector - A selector for collection maps uniquely
/// @param {Map} $prop-map-to-be-cached - Map to be cached
/// @param {String} $unusable-bp - Breakpoint keys that won't be cached
/// @param {String} $min-bp-key - Default breakpoint key
/// @return {Map} - Modified cache
@function maple-cache($cache, $bp-key, $selector, $prop-map-to-be-cached, $unusable-bp, $min-bp-key) {
  @if map-get($unusable-bp, $bp-key) != null {
    $bp-key: $min-bp-key;
  }

  $cache-item: map-get($cache, $bp-key);

  @if $cache-item == null {
    @error "\"#{$bp-key}\" is not a known breakpoint \"#{join(map-keys($cache), (), $separator: comma, $bracketed: false)}\".";
  }

  $cache-item: map-recursive-merge(
    $cache-item,
    (
      #{$selector}: $prop-map-to-be-cached,
    )
  );

  $cache: map-merge(
    $cache,
    (
      #{$bp-key}: $cache-item,
    )
  );

  @return $cache;
}
